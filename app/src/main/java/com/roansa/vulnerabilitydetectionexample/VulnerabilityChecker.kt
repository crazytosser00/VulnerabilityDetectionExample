package com.roansa.vulnerabilitydetectionexample

import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.Signature
import android.os.Build
import android.util.Base64
import android.util.Log
import com.scottyab.rootbeer.RootBeer
import java.lang.reflect.InvocationTargetException
import java.security.MessageDigest

class VulnerabilityChecker(
    private val context: Context
) {

    private val rootBeer = RootBeer(context)

    fun isRooted(): Boolean = rootBeer.isRooted && rootBeer.isRootedWithBusyBoxCheck

    fun hasInstalledFromMarket(): Boolean {
        val installerName =
            context.packageManager.getInstallSourceInfo(context.packageName).installingPackageName
        return installerName != null && INSTALLER_PACKAGE_NAME == installerName
    }

    fun isRunningInEmulatorEnvironment(): Boolean {
        val property1: Boolean =
            getSystemProperty(SYSTEM_PROPERTY_1)?.contains(PROPERTY_HARDWARE) ?: false
        val property2: Boolean =
            getSystemProperty(SYSTEM_PROPERTY_2)?.isNotEmpty() ?: false
        val property3 =
            getSystemProperty(SYSTEM_PROPERTY_3) == PROPERTY_MODEL

        return property1 || property2 || property3
    }

    fun isInDebugMode(): Boolean =
        (context.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) == 0 && !BuildConfig.DEBUG

    @SuppressLint("PackageManagerGetSignatures")
    fun isAppSignatureCorrect(): Boolean {
        try {
            val signatures: Array<Signature>? =
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    context.packageManager.getPackageInfo(
                        context.packageName,
                        PackageManager.GET_SIGNING_CERTIFICATES
                    ).signingInfo.apkContentsSigners
                } else {
                    context.packageManager.getPackageInfo(
                        context.packageName,
                        PackageManager.GET_SIGNATURES
                    ).signatures
                }

            if (signatures != null && signatures.isNotEmpty()) {
                for (signature in signatures) {
                    val messageDigest = MessageDigest.getInstance(SHA)
                    messageDigest.update(signature.toByteArray())
                    val currentSignature =
                        Base64.encodeToString(messageDigest.digest(), Base64.DEFAULT)

                    Log.d("SIGNATURE =%s", currentSignature)

                    return APP_SIGNATURE != currentSignature.trim()
                }
            } else {
                return false
            }
        } catch (e: Exception) {
            Log.e("VulnerabilityChecker", "", e)
        }
        return true
    }

    @SuppressLint("PrivateApi")
    @Throws(
        ClassNotFoundException::class,
        NoSuchMethodException::class,
        InvocationTargetException::class,
        IllegalAccessException::class
    )
    private fun getSystemProperty(name: String): String? {
        val systemPropertyClazz = Class.forName(PROPERTIES_CLASS_NAME)
        return systemPropertyClazz.getMethod(SYSTEM_PROPERTIES_METHOD, String::class.java)
            .invoke(systemPropertyClazz, name) as String
    }

    companion object {
        private const val INSTALLER_PACKAGE_NAME: String = "com.android.vending"

        private const val APP_SIGNATURE = ""
        private const val SHA = "SHA"

        private const val PROPERTIES_CLASS_NAME = "android.os.SystemProperties"
        private const val SYSTEM_PROPERTIES_METHOD = "get"
        private const val SYSTEM_PROPERTY_1 = "ro.hardware"
        private const val SYSTEM_PROPERTY_2 = "ro.kernel.emu"
        private const val SYSTEM_PROPERTY_3 = "ro.product.model"
        private const val PROPERTY_HARDWARE = "goldfish"
        private const val PROPERTY_MODEL = "sdk"
    }

}